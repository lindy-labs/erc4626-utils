# Properties of YieldStreams

## Overview of the YieldStreams

The smart contract YieldStreams introduces a unique method for yield streaming, utilizing ERC721 tokens to represent individual streams and integrating ERC4626 vaults for yield generation. Each yield stream is uniquely identified by an ERC721 token, allowing for transparent tracking and management. Users can easily create, replenish, transfer, and close yield streams, while also directing generated yield to designated beneficiaries. Leveraging the ERC4626 standard for tokenized vault interactions, the system ensures that these tokens appreciate over time, generating yield for their holders. This cohesive approach combines the benefits of ERC721 streams and ERC4626 vaults, providing a robust framework for managing and profiting from yield streams.

It has mainly the following state variables:
* `vault` (type `IERC4626`), The ERC4626 vault contract used for yield generation.
* `asset` (type `IERC20`), The underlying ERC20 asset of the ERC4626 vault.
* `receiverTotalShares` (type `mapping(address => uint256)`), A mapping that tracks the total number of shares allocated to each receiver across all their yield streams.
* `receiverTotalPrincipal` (type `mapping(address => uint256)`), A mapping that tracks the total principal amount (in asset units) allocated to each receiver across all their yield streams.
* `receiverPrincipal` (type `mapping(address => mapping(uint256 => uint256))`), A nested mapping that tracks the principal amount (in asset units) allocated to each individual yield stream for each receiver.
* `streamIdToReceiver` (type `mapping(uint256 => address)`), A mapping that associates each yield stream ID (ERC721 token ID) with the receiver's address.
* `nextStreamId` (type `uint256`), A counter that keeps track of the next available ID for a new yield stream (ERC721 token).
* `name_` (type `string`), The name of the ERC721 token representing the yield streams.
* `symbol_` (type `string`), The symbol of the ERC721 token representing the yield streams.

It has the following external/functions that change state variables:
* `open(address _owner, address _receiver, uint256 _shares, uint256 _maxLossOnOpenTolerance) public returns (uint256 streamId)`, Opens a new yield stream between the caller (streamer) and a receiver, represented by an ERC721 token.
* `openUsingPermit(address _owner, address _receiver, uint256 _shares, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 streamId)`, Opens a new yield stream for a specified receiver using ERC4626 permit for setting the allowance.
* `openMultiple(address _owner, uint256 _shares, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance) public returns (uint256[] memory streamIds)`, Opens multiple yield streams between a specified owner and multiple receivers, represented by ERC721 tokens.
* `openMultipleUsingPermit(address _owner, uint256 _shares, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256[] memory streamIds)`, Opens multiple yield streams between a specified owner and multiple receivers using ERC4626 permit for setting the allowance.
* `depositAndOpen(address _owner, address _receiver, uint256 _principal, uint256 _maxLossOnOpenTolerance) public returns (uint256 streamId)`, Opens a new yield stream between a specified owner and a receiver, represented by an ERC721 token, by depositing the specified principal amount of the vault's underlying ERC20 asset.
* `depositAndOpenUsingPermit(address _owner, address _receiver, uint256 _principal, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 streamId)`, Opens a new yield stream for a specified receiver using the vault's underlying ERC20 asset and ERC20 permit for setting the allowance.
* `depositAndOpenMultiple(address _owner, uint256 _principal, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance) public returns (uint256[] memory streamIds)`, Opens multiple yield streams between a specified owner and multiple receivers, represented by ERC721 tokens, by depositing the specified principal amount of the vault's underlying ERC20 asset.
* `depositAndOpenMultipleUsingPermit(address _owner, uint256 _principal, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256[] memory streamIds)`, Opens multiple yield streams for a specified owner and multiple receivers using the vault's underlying ERC20 asset and ERC20 permit for setting the allowance.
* `topUp(uint256 _streamId, uint256 _shares) public returns (uint256 principal)`, Adds additional ERC4626 shares to an existing yield stream, increasing the principal allocated to the receiver.
* `topUpUsingPermit(uint256 _streamId, uint256 _shares, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 principal)`, Adds additional ERC4626 shares to an existing yield stream using permit for approval.
* `depositAndTopUp(uint256 _streamId, uint256 _principal) public returns (uint256 shares)`, Adds additional principal (underlying ERC20 asset) to an existing yield stream, increasing the allocated principal.
* `depositAndTopUpUsingPermit(uint256 _streamId, uint256 _principal, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 shares)`, Adds additional principal (underlying ERC20 asset) to an existing yield stream using permit for approval.
* `close(uint256 _streamId) external returns (uint256 shares)`, Closes an existing yield stream, returning the remaining shares (principal) to the streamer.
* `setTokenCID(uint256 _tokenId, string memory _cid) public`, Sets the IPFS CID (Content Identifier) for a given token ID.
* `approveClaimer(address _claimer) external`, Approves a specified address to claim yield on behalf of the receiver.
* `revokeClaimer(address _claimer) external`, Revokes approval for a specified address to claim yield on behalf of the receiver.
* `claimYield(address _receiver, address _sendTo) external returns (uint256 assets)`, Claims the generated yield from all streams for the specified receiver and transfers it to a specified address.
* `claimYieldInShares(address _receiver, address _sendTo) external returns (uint256 yieldInShares)`, Claims the generated yield from all streams for the specified receiver and transfers it in shares to a specified address.

It has the following view functions, which do not change state:
* `name() public view override returns (string memory)`, Inherited from ERC721, returns the name of the ERC721 token.
* `symbol() public view override returns (string memory)`, Inherited from ERC721, returns the symbol of the ERC721 token.
* `tokenURI(uint256 id) public view virtual override returns (string memory)`, Inherited from ERC721, returns the URI for a given token ID.
* `previewOpen(address _receiver, uint256 _shares, uint256 _maxLossOnOpenTolerance) public view returns (uint256 principal)`, Previews the principal amount that would be allocated when opening a new stream with shares.
* `previewDepositAndOpen(address _receiver, uint256 _principal, uint256 _maxLossOnOpenTolerance) public view returns (uint256 shares)`, Previews the shares that would be allocated when opening a new stream with the underlying ERC20 asset as principal.
* `previewClose(uint256 _streamId) public view returns (uint256 shares)`, Previews the shares that would be returned upon closing a yield stream.
* `previewClaimYield(address _receiver) public view returns (uint256 yield)`, Provides an estimation of the yield available to be claimed by the specified receiver in asset units.
* `previewClaimYieldInShares(address _receiver) public view returns (uint256 yieldInShares)`, Provides an estimation of the yield available to be claimed by the specified receiver in share units.
* `debtFor(address _receiver) public view returns (uint256)`, Calculates the total debt for a given receiver across all yield streams.
* `getPrincipal(uint256 _streamId) external view returns (uint256)`, Retrieves the principal amount allocated to a specific yield stream.
* `isOwnerOrApproved(address _account, uint256 _streamId) external view returns (bool)`, Checks if the specified account is the owner or an approved operator of the given yield stream.


## Properties

* Note that we are focusing only on the positive properties as long as we have test cases that showed the revert cases.

* The Certora Prover report all the below properties can be found [here](https://prover.certora.com/output/729163/090ec216dcc2461782ceeeb213d0c525?anonymousKey=543cfab1c1bdb537b9ebd6c5bd66dda14bd50740)

| No. | Property  | Category | Priority | Specified | Verified |
| ---- | --------  | -------- | -------- | -------- | -------- |
| 1 | `open(address _owner, address _receiver, uint256 _shares, uint256 _maxLossOnOpenTolerance)` should open a new yield stream between the caller (streamer) and a receiver, represented by an ERC721 token | high level | high | Y | Y |
| 2 | `openUsingPermit(address _owner, address _receiver, uint256 _shares, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 streamId)` should open a new yield stream for a specified receiver using ERC4626 permit for setting the allowance | high level | high | Y | Y |
| 3 | `openMultiple(address _owner, uint256 _shares, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance)` should open multiple yield streams between a specified owner and multiple receivers, represented by ERC721 tokens | high level | high | Y | Y |
| 4 | `openMultipleUsingPermit(address _owner, uint256 _shares, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256[] memory streamIds)` should open multiple yield streams between a specified owner and multiple receivers using ERC4626 permit for setting the allowance | high level | high | Y | Y |
| 5 | `depositAndOpen(address _owner, address _receiver, uint256 _principal, uint256 _maxLossOnOpenTolerance)` should create a new yield stream with the correct parameters, deposit the specified principal amount, and update the contract state accordingly, regardless of the caller | high level | high | Y | Y |
| 6 | `depositAndOpenUsingPermit(address _owner, address _receiver, uint256 _principal, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 streamId)` should open a new yield stream using ERC20 permit for approval, allocating the underlying asset as principal | high level | high | Y | Y |
| 7 | `depositAndOpenMultiple(address _owner, uint256 _principal, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance)` should create multiple new yield streams with the correct parameters, deposit the specified principal amount, and update the contract state accordingly, regardless of the caller | high level | high | Y | Y |
| 8 | `depositAndOpenMultipleUsingPermit(address _owner, uint256 _principal, address[] calldata _receivers, uint256[] calldata _allocations, uint256 _maxLossOnOpenTolerance, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256[] memory streamIds)` should open multiple yield streams using ERC20 permit for approval, allocating the underlying asset as principal | high level | high | Y | Y |
| 9 | `topUp(uint256 _streamId, uint256 _shares)` should add the specified shares to the existing yield stream and update the contract state accordingly, if the caller is the owner of the stream | high level | high | Y | Y |
| 10 | `topUpUsingPermit(uint256 _streamId, uint256 _shares, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 principal)` should add additional ERC4626 shares to an existing yield stream using permit for approval | high level | high | Y | Y |
| 11 | `depositAndTopUp(uint256 _streamId, uint256 _principal)` should add the specified principal amount to the existing yield stream, deposit the principal, and update the contract state accordingly, if the caller is the owner of the stream | high level | high | Y | Y |
| 12 | `depositAndTopUpUsingPermit(uint256 _streamId, uint256 _principal, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (uint256 shares)` should add additional principal (underlying ERC20 asset) to an existing yield stream using permit for approval | high level | high | Y | Y |
| 13 | `close(uint256 _streamId)` should close the specified yield stream, return the remaining shares to the caller (if the caller is the owner), and update the contract state accordingly | high level | high | Y | Y |
| 14 | `claimYield(address _receiver, address _sendTo)` should calculate and transfer the total yield generated for the caller across all their yield streams to the specified address, and update the contract state accordingly | high level | high | Y | Y |
| 15 | `verify_claimYield_toSelf(address alice, address bob, uint256 _principal, uint8 parts)` should verify the correct behavior of the claimYield function when the receiver claims the yield to their own address, ensuring that the streamer's share balance is reduced to zero, and the receiver's asset balance is increased by the claimed yield amount | high level | high | Y | Y |
| 16 | `verify_claimYield_toAnotherAccount(address alice, address bob, address carol, uint256 _principal, uint8 parts)` should verify the correct behavior of the claimYield function when the receiver (bob) claims the yield to a different account (carol). It ensures that the streamer's (alice) share balance is reduced to zero, the receiver's (bob) asset balance remains unchanged, and the claimed yield amount is transferred to the specified account (carol) | high level | high | Y | Y |
| 17 | `verify_claimYield_claimsFromAllOpenedStreams(address alice, address carol, address bob, uint256 alicesPrincipal, uint256 bobsPrincipal, uint8 multiple, uint8 desloc)` should verify the correct behavior of the claimYield function when the receiver (carol) claims the yield from multiple opened streams. It sets up a scenario where two yield streams are opened, one between alice and carol, and another between bob and carol, with specified principal amounts. The rule then generates yield by adding a percentage of the principals to the vault's balance. Finally, it invokes the claimYield function with carol as the receiver and asserts that the claimed yield is correctly calculated and transferred to carol's asset balance, while ensuring that the contract's state is updated accordingly | high level | high | Y | Y |
| 18 | `verify_claimYieldInShares_toSelf(address alice, address bob, uint256 _principal, uint8 parts)` should verify the correct behavior of the claimYieldInShares function when the receiver (bob) claims the yield in the form of shares to their own address. It sets up a scenario where a yield stream is opened between alice (the streamer) and bob (the receiver), with a specified principal amount. The rule then generates yield by adding a percentage of the principal to the vault's balance. Finally, it invokes the claimYieldInShares function with bob as the receiver and asserts that the claimed yield in shares is correctly calculated and transferred to bob's share balance, while ensuring that the contract's state is updated accordingly | high level | high | Y | Y |
| 19 | `verify_claimYieldInShares_toAnotherAccount(address alice, address bob, address carol, uint256 _principal, uint8 parts)` should verifies the correct behavior of the claimYieldInShares function when the receiver (bob) claims the yield in the form of shares to a different account (carol). It sets up a scenario where a yield stream is opened between alice (the streamer) and bob (the receiver), with a specified principal amount. The rule then generates yield by adding a percentage of the principal to the vault's balance. Finally, it invokes the claimYieldInShares function with carol as the recipient and asserts that the claimed yield in shares is correctly calculated and transferred to carol's share balance, while ensuring that the contract's state is updated accordingly | high level | high | Y | Y |
| 20 | `integrity_of_setTokenCID` should ensure that the setTokenCID function only allows the contract owner to update the token CID | low level | low | Y | Y |
| 21 | `integrity_of_approveClaimer` should ensure that the approveClaimer function only allows the contract owner to approve a claimer | low level | low | Y | Y |
| 22 |  `integrity_of_revokeClaimer` should ensure that the revokeClaimer function only allows the contract owner to revoke a claimer | low level | low | Y | Y |
| 23 | `verify_yieldcalculation_when_totalshares_is_greater_than_totalprincipal(address receiver)` should verify that when the total value of a receiver's shares is greater than their total principal amount, the previewClaimYield function correctly calculates the yield by subtracting the principal from the current value of the shares | low level | low | Y | Y |
| 24 | `composition_of_approve_and_revokeClaimer(address receiver, address _claimer)` should revoke should revoke approval created by approveClaimer | High level | high | Y | Y |
| 25 | `composition_of_open_and_topUp(address _owner, address _receiver, uint256 _shares, uint256 _maxLossOnOpenTolerance, uint256 _additionalShares)` should compose the function open with the function topup correctly | High level | high | Y | Y |
| 26 | `composition_of_open_and_close(address _owner, address _receiver, uint256 _shares, uint256 _maxLossOnOpenTolerance)` should compose the function open with the function close correctly | High level | high | Y | Y |
| 27 | `relationshiip_between_previewOpen_and_previewDepositAndOpen(env e, address receiver, uint256 shares, uint256 maxLossOnOpenTolerance)` should establishe the relationship between PreviewOpen and PreviewDepositAndOpen | High level | high | Y | Y |
| 28 | `composition_of_topUp_and_close(uint256 streamId, uint256 shares)` topping up a yield stream and then immediately closing it should leave the contract state unchanged | High level | high | Y | Y |
| 29 | `composition_of_deposit_and_topUp_and_close(uint256 streamId, uint256 principal)` depositing additional principal and topping up a yield stream, and then immediately closing it should leave the contract state unchanged | High level | high | Y | Y |
| 30 | `composition_of_openMultiple_and_close(address owner, uint256 shares, address[] receivers, uint256[] allocations, uint256 maxLossOnOpenTolerance)` should open multiple streams and closes them correctly | High level | high | Y | Y |
| 31 | `composition_of_open_and_topUp_and_close(address owner, address receiver, uint256 shares, uint256 topUpShares, uint256 maxLossOnOpenTolerance)` should open, top up, and close a stream correctly | High level | high | Y | Y |
| 32 | `composition_of_open_and_claimYieldInShares(address owner, address receiver, uint256 shares, uint256 maxLossOnOpenTolerance, uint256 yieldShares)` should open a stream and claim yield in shares in a single transaction | High level | high | Y | Y |
| 33 | `composition_of_open_and_claimYield(address owner, address receiver, uint256 shares, uint256 maxLossOnOpenTolerance, uint256 yieldShares)` should open a stream and claim yields in a single transaction | High level | high | Y | Y |
| 34 | `composition_of_deposit_and_open_and_claimYield(address owner, address receiver, uint256 principal, uint256 maxLossOnOpenTolerance,uint256 yieldShares)` should deposit principal, open a stream, and claim yield in shares in a single transaction | High level | high | Y | Y |
| 35 | `composition_of_openMultiple_and_topUp_and_claimYieldInShares(address owner, uint256 shares, address[] receivers, uint256[] allocations, uint256 maxLossOnOpenTolerance, uint256 topUpStreamId, uint256 topUpShares, uint256 yieldShares)` should perform an Open Multiple, Top Up and Claim Yield in Shares correctly | High level | high | Y | Y |
| 36 | `composition_of_openMultiple_and_topUp_and_claimYield(address owner, uint256 shares, address[] receivers, uint256[] allocations, uint256 maxLossOnOpenTolerance, uint256 topUpStreamId, uint256 topUpShares, uint256 yieldShares)` should compose OpenMultiple, TopUp, and Claim Yields correctly | High level | high | Y | Y |
| 37 | `consistency_between_previewClaimYield_and_previewClaimYieldInShares(address receiver)` should ensure that the previewClaimYield and previewClaimYieldInShares functions are consistent for each receiver | High level | high | Y | Y |
| 38 | `consistency_between_previewOpen_and_previewDeposit_and_open(address receiver, uint256 shares, uint256 maxLossOnOpenTolerance)` should ensure that the previewOpen and previewDepositAndOpen functions are consistent for a given receiver, shares, and maxLossOnOpenTolerance | High level | high | Y | Y |
| 39 | `consistency_betweeb_previewOpen_and_previewClose_and_previewClaimYieldInShares(address owner, address receiver, uint256 shares, uint256 maxLossOnOpenTolerance)` should ensure that the previewOpen, previewClose, and previewClaimYieldInShares functions are consistent for a given receiver, shares, and maxLossOnOpenTolerance | High level | high | Y | Y |
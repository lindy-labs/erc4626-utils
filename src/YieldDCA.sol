// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.19;

import {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";
import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
import {SafeCastLib} from "solady/utils/SafeCastLib.sol";
import {ReentrancyGuard} from "solady/utils/ReentrancyGuard.sol";
import {ERC721} from "solady/tokens/ERC721.sol";
import {IERC721} from "openzeppelin-contracts/interfaces/IERC721.sol";
import {IERC20} from "openzeppelin-contracts/interfaces/IERC20.sol";
import {IERC20Metadata} from "openzeppelin-contracts/interfaces/IERC20Metadata.sol";
import {IERC4626} from "openzeppelin-contracts/interfaces/IERC4626.sol";
import {IERC20Permit} from "openzeppelin-contracts/token/ERC20/extensions/IERC20Permit.sol";
import {AccessControl} from "openzeppelin-contracts/access/AccessControl.sol";
import {Multicall} from "openzeppelin-contracts/utils/Multicall.sol";

import {CommonErrors} from "./common/CommonErrors.sol";
import {ISwapper} from "./interfaces/ISwapper.sol";

/**
 * @title YieldDCA
 * @notice Implements a Dollar Cost Averaging (DCA) strategy by utilizing the yield generated by an ERC4626 vault.
 * @dev This contract automates the DCA strategy by regularly converting the yield generated by an ERC4626 vault into a specified ERC20 DCA token at regular intervals, called epochs.
 *
 * ## Key Features
 * - **Position Management:** Allows users and their approved operators to open, close, increase, and reduce DCA positions represented by ERC721 tokens.
 * - **Automatic Yield Conversion:** Converts yield to DCA tokens at fixed intervals (epochs).
 * - **Position Tracking:** Tracks the yield generated from user positions and allocates DCA tokens accordingly.
 * - **Configurable Parameters:** Admins can configure epoch duration, minimum yield per epoch, and discrepancy tolerance.
 * - **Role-Based Access Control:** Utilizes AccessControl for managing admin and keeper roles.
 *
 * ## Roles
 * - `DEFAULT_ADMIN_ROLE`: Manages configuration settings such as epoch duration, minimum yield per epoch, discrepancy tolerance, and the swapper contract.
 * - `KEEPER_ROLE`: Authorized to execute the DCA strategy at the end of each epoch.
 *
 * ## External Integrations
 * - **ERC4626 Vault:** Manages the underlying asset and generates yield.
 * - **ERC20 Token:** Acts as the target DCA token.
 * - **Swapper Contract:** Facilitates the exchange of yield for DCA tokens.
 *
 * ## Security Considerations
 * - **Input Validation:** Ensures all input parameters are valid and within acceptable ranges.
 * - **Reentrancy Guards:** Protects against reentrancy attacks using checks-effects-interactions pattern and reentrancy guards.
 * - **Access Control:** Restricts critical functions to authorized roles only.
 * - **Use of Safe Libraries:** Utilizes SafeCastLib and other safety libraries to prevent overflows and underflows.
 * - **Non-Upgradable:** The contract is designed to be non-upgradable to simplify security and maintainability.
 *
 * ## Usage
 * Users and their approved operators can open and manage positions using both direct interactions and ERC20 permit-based approvals. Positions are represented as ERC721 tokens, enabling easy tracking and management of each user's investments.
 */
contract YieldDCA is ERC721, ReentrancyGuard, AccessControl, Multicall {
    using CommonErrors for uint256;
    using CommonErrors for address;
    using FixedPointMathLib for uint256;
    using SafeCastLib for uint256;
    using SafeTransferLib for address;

    struct Position {
        uint256 shares;
        uint256 principal;
        uint224 dcaBalance;
        uint32 epoch;
    }

    // NOTE: Using uint128 to pack variables and save on sstore/sload operations since both values are always written/read together.
    // dcaPrice and sharePrice are in WAD format and represent the result of dividing two uint256 values.
    // In case of overflow, SafeCastLib will revert the transaction to prevent incorrect results.
    struct EpochInfo {
        uint128 dcaPrice;
        uint128 sharePrice;
    }

    /**
     * @notice Emitted when the epoch duration is updated by an admin.
     * @param admin The address of the admin who updated the epoch duration.
     * @param oldDuration The previous duration of the epoch.
     * @param newDuration The new duration of the epoch.
     */
    event EpochDurationUpdated(address indexed admin, uint32 oldDuration, uint32 newDuration);

    /**
     * @notice Emitted when the minimum yield per epoch is updated by an admin.
     * @param admin The address of the admin who updated the minimum yield.
     * @param oldMinYield The previous minimum yield per epoch.
     * @param newMinYield The new minimum yield per epoch.
     */
    event MinYieldPerEpochUpdated(address indexed admin, uint64 oldMinYield, uint64 newMinYield);

    /**
     * @notice Emitted when the swapper contract is updated by an admin.
     * @param admin The address of the admin who updated the swapper.
     * @param oldSwapper The address of the previous swapper contract.
     * @param newSwapper The address of the new swapper contract.
     */
    event SwapperUpdated(address indexed admin, address oldSwapper, address newSwapper);

    /**
     * @notice Emitted when the discrepancy tolerance is updated by an admin.
     * @param admin The address of the admin who updated the discrepancy tolerance.
     * @param oldTolerance The previous discrepancy tolerance.
     * @param newTolerance The new discrepancy tolerance.
     */
    event DiscrepancyToleranceUpdated(address indexed admin, uint64 oldTolerance, uint64 newTolerance);

    /**
     * @notice Emitted when the DCA strategy is executed.
     * @param keeper The address of the keeper who executed the DCA strategy.
     * @param epoch The epoch number in which the DCA strategy was executed.
     * @param yieldSpent The amount of yield spent in the DCA execution.
     * @param dcaBought The amount of DCA tokens bought.
     * @param dcaPrice The price of the DCA tokens.
     * @param sharePrice The price of the vault shares.
     */
    event DCAExecuted(
        address indexed keeper,
        uint32 epoch,
        uint256 yieldSpent,
        uint256 dcaBought,
        uint128 dcaPrice,
        uint128 sharePrice
    );

    /**
     * @notice Emitted when a new DCA position is opened.
     * @param caller The address of the caller who opened the position.
     * @param owner The address of the owner of the position.
     * @param positionId The ID of the newly created position.
     * @param epoch The epoch in which the position was opened.
     * @param shares The amount of shares deposited in the position.
     * @param principal The principal amount of the position.
     */
    event PositionOpened(
        address indexed caller,
        address indexed owner,
        uint256 indexed positionId,
        uint32 epoch,
        uint256 shares,
        uint256 principal
    );

    /**
     * @notice Emitted when a DCA position is increased.
     * @param caller The address of the caller who increased the position.
     * @param owner The address of the owner of the position.
     * @param positionId The ID of the position.
     * @param epoch The epoch in which the position was increased.
     * @param shares The additional amount of shares added to the position.
     * @param principal The additional principal amount added to the position.
     */
    event PositionIncreased(
        address indexed caller,
        address indexed owner,
        uint256 indexed positionId,
        uint32 epoch,
        uint256 shares,
        uint256 principal
    );

    /**
     * @notice Emitted when a DCA position is reduced.
     * @param caller The address of the caller who reduced the position.
     * @param owner The address of the owner of the position.
     * @param positionId The ID of the position.
     * @param epoch The epoch in which the position was reduced.
     * @param shares The amount of shares withdrawn from the position.
     * @param principal The principal amount withdrawn from the position.
     */
    event PositionReduced(
        address indexed caller,
        address indexed owner,
        uint256 indexed positionId,
        uint32 epoch,
        uint256 shares,
        uint256 principal
    );

    /**
     * @notice Emitted when a DCA position is closed.
     * @param caller The address of the caller who closed the position.
     * @param owner The address of the owner of the position.
     * @param positionId The ID of the position.
     * @param epoch The epoch in which the position was closed.
     * @param shares The amount of shares withdrawn from the position.
     * @param principal The principal amount withdrawn from the position.
     * @param dcaBalance The DCA balance claimed from the position.
     */
    event PositionClosed(
        address indexed caller,
        address indexed owner,
        uint256 indexed positionId,
        uint32 epoch,
        uint256 shares,
        uint256 principal,
        uint256 dcaBalance
    );

    /**
     * @notice Emitted when the DCA balance of a position is claimed.
     * @param caller The address of the caller who claimed the DCA balance.
     * @param owner The address of the owner of the position.
     * @param positionId The ID of the position.
     * @param epoch The epoch in which the DCA balance was claimed.
     * @param amount The amount of DCA tokens claimed.
     * @param to The address to which the DCA tokens were sent.
     */
    event DCABalanceClaimed(
        address indexed caller,
        address indexed owner,
        uint256 indexed positionId,
        uint32 epoch,
        uint256 amount,
        address to
    );

    /**
     * @notice Emitted when the CID (Content Identifier) is updated for a token.
     * @param caller The address of the caller who updated the CID.
     * @param owner The address that owns the token.
     * @param tokenId The ID of the token for which the CID was updated.
     * @param cid The new CID associated with the token.
     */
    event TokenCIDUpdated(address indexed caller, address indexed owner, uint256 indexed tokenId, string cid);

    error DCATokenAddressZero();
    error VaultAddressZero();
    error SwapperAddressZero();
    error DCATokenSameAsVaultAsset();
    error KeeperAddressZero();
    error AdminAddressZero();
    error EpochDurationOutOfBounds();
    error MinYieldPerEpochOutOfBounds();
    error DiscrepancyToleranceOutOfBounds();

    error EpochDurationNotReached();
    error InsufficientYield();
    error NoYield();
    error AmountReceivedTooLow();
    error InsufficientSharesToWithdraw();
    error NothingToClaim();
    error DCADiscrepancyAboveTolerance();
    error EmptyCID();

    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");

    uint32 public constant EPOCH_DURATION_LOWER_BOUND = 5 days;
    uint32 public constant EPOCH_DURATION_UPPER_BOUND = 10 weeks;
    uint64 public constant MIN_YIELD_PER_EPOCH_UPPER_BOUND = 0.01e18; // 1%
    uint64 public constant DISCREPANCY_TOLERANCE_UPPER_BOUND = 1e18; // 100%

    /// @notice The ERC20 token used for DCA.
    IERC20 public immutable dcaToken;
    /// @notice The underlying asset of the ERC4626 vault.
    IERC20 public immutable asset;
    /// @notice The yield generating ERC4626 vault managing the underlying asset.
    IERC4626 public immutable vault;

    // * SLOT 0
    /**
     * @notice The current epoch number (starting from 1).
     * @dev Tracks the number of epochs that have occurred.
     */
    uint32 public currentEpoch = 1;
    /**
     * @notice The start time of the current epoch.
     * @dev Used to determine when the next epoch can start based on the `epochDuration`.
     */
    uint64 public currentEpochTimestamp = uint64(block.timestamp);
    /**
     * @notice The minimum interval between epochs (executing DCA) in seconds.
     * @dev Configurable by an admin to set the duration of each epoch.
     */
    uint32 public epochDuration = 2 weeks;
    /**
     * @notice The minimum yield required per epoch as a WAD-scaled percentage of the total principal.
     * @dev Configurable by an admin to ensure a minimum yield before executing the DCA strategy.
     */
    uint64 public minYieldPerEpoch = 0; // 0.1%
    /**
     * @notice The maximum discrepancy between the expected and actual DCA token amounts for a claim.
     * @dev Configurable by an admin to set the acceptable discrepancy tolerance for DCA token claims.
     */
    uint64 public discrepancyTolerance = 0.01e18; // 1%

    // * SLOT 1
    /**
     * @notice The address of the swapper contract used to exchange yield for DCA tokens.
     * @dev The swapper contract facilitates the exchange of assets during DCA execution.
     */
    ISwapper public swapper;
    /**
     * @notice The ID of the next opened position.
     * @dev Increments with each new position to ensure unique IDs for each DCA position.
     */
    uint96 public nextPositionId = 1;

    // * SLOT 2 ...
    /**
     * @notice The total principal amount of all positions.
     * @dev Tracks the total amount of principal deposited by all positions in the contract.
     */
    uint256 public totalPrincipal;

    /**
     * @notice The epoch information for each completed epoch.
     * @dev Maps epoch numbers to their respective `EpochInfo` structures containing DCA and share prices.
     */
    mapping(uint256 => EpochInfo) public epochInfos;

    /**
     * @notice The position ID to position details.
     * @dev Maps position IDs to their respective `Position` structures containing shares, principal, DCA balance, and epoch.
     */
    mapping(uint256 => Position) public positions;

    /**
     * @notice Mapping from token ID to IPFS CID (Content Identifier).
     * @dev This mapping stores the IPFS CID associated with each token ID.
     * The CID is used to generate the tokenURI.
     */
    mapping(uint256 => string) public tokenCIDs;

    modifier onlyAdmin() {
        _checkRole(DEFAULT_ADMIN_ROLE);
        _;
    }

    // ERC721 name and symbol
    string private name_;
    string private symbol_;

    /**
     * @notice Initializes the YieldDCA contract.
     * @dev Sets up the DCA strategy contract with the specified parameters, including the ERC20 token for DCA, the ERC4626 vault, the swapper contract, and the initial configuration parameters.
     * Assigns the DEFAULT_ADMIN_ROLE to the provided admin address and the KEEPER_ROLE to the provided keeper address.
     * Approves the vault to spend the underlying assets.
     * @param _dcaToken The address of the ERC20 token used for DCA.
     * @param _vault The address of the underlying ERC4626 vault contract.
     * @param _swapper The address of the swapper contract used to exchange yield for DCA tokens.
     * @param _epochDuration The minimum duration between epochs in seconds.
     * @param _minYieldPerEpochPercent The minimum yield required per epoch as a WAD-scaled percentage of the total principal.
     * @param _admin The address with the admin role.
     * @param _keeper The address with the keeper role.
     *
     * @custom:requirements
     * - `_dcaToken` must not be the zero address.
     * - `_vault` must not be the zero address.
     * - `_dcaToken` must not be the same as the vault's underlying asset.
     * - `_admin` must not be the zero address.
     * - `_keeper` must not be the zero address.
     *
     * @custom:reverts
     * - `DCATokenAddressZero` if `_dcaToken` is the zero address.
     * - `VaultAddressZero` if `_vault` is the zero address.
     * - `DCATokenSameAsVaultAsset` if `_dcaToken` is the same as the vault's underlying asset.
     * - `AdminAddressZero` if `_admin` is the zero address.
     * - `KeeperAddressZero` if `_keeper` is the zero address.
     */
    constructor(
        IERC20 _dcaToken,
        IERC4626 _vault,
        ISwapper _swapper,
        uint32 _epochDuration,
        uint64 _minYieldPerEpochPercent,
        address _admin,
        address _keeper
    ) {
        // validate input parameters
        address(_dcaToken).revertIfZero(DCATokenAddressZero.selector);
        address(_vault).revertIfZero(VaultAddressZero.selector);
        _admin.revertIfZero(AdminAddressZero.selector);
        _keeper.revertIfZero(KeeperAddressZero.selector);

        if (address(_dcaToken) == _vault.asset()) revert DCATokenSameAsVaultAsset();

        // set contract state
        dcaToken = _dcaToken;
        asset = IERC20(_vault.asset());
        vault = _vault;

        _setSwapper(_swapper);
        _setEpochDuration(_epochDuration);
        _setMinYieldPerEpoch(_minYieldPerEpochPercent);

        name_ =
            string(abi.encodePacked("Yield DCA - ", _vault.name(), " / ", IERC20Metadata(address(_dcaToken)).name()));
        symbol_ = string(abi.encodePacked("yDCA-", _vault.symbol(), "/", IERC20Metadata(address(_dcaToken)).symbol()));

        // set roles
        _grantRole(DEFAULT_ADMIN_ROLE, _admin);
        _grantRole(KEEPER_ROLE, _keeper);

        // approve the vault as underlying assets spender
        address(asset).safeApprove(address(_vault), type(uint256).max);
    }

    /*
    * =======================================================
    *                   EXTERNAL FUNCTIONS
    * =======================================================
    */

    // *** admin functions ***

    /**
     * @notice Updates the address of the swapper contract used to exchange yield for DCA tokens.
     * @dev Restricted to admin role. The new swapper address must be a valid contract address.
     * @param _newSwapper The address of the new swapper contract.
     *
     * @custom:requirements
     * - `_newSwapper` must not be the zero address.
     * - caller must have the admin role.
     *
     * @custom:reverts
     * - `SwapperAddressZero` if `_newSwapper` is the zero address.
     * - `AccessControlUnauthorizedAccount` if the caller does not have the `DEFAULT_ADMIN_ROLE`.
     *
     * @custom:emits
     * - Emits {SwapperUpdated} event upon successful swapper update.
     */
    function setSwapper(ISwapper _newSwapper) external onlyAdmin {
        address oldSwapper = _setSwapper(_newSwapper);

        emit SwapperUpdated(msg.sender, oldSwapper, address(_newSwapper));
    }

    /**
     * @notice Sets the minimum interval between epochs (DCA executions) in seconds.
     * @dev Restricted to admin role. The duration must be between `EPOCH_DURATION_LOWER_BOUND` and `EPOCH_DURATION_UPPER_BOUND`.
     * @param _newDuration The new minimum duration in seconds.
     *
     * @custom:requirements
     * - `_newDuration` must be between `EPOCH_DURATION_LOWER_BOUND` and `EPOCH_DURATION_UPPER_BOUND`.
     * - caller must have the admin role.
     *
     * @custom:reverts
     * - `EpochDurationOutOfBounds` if `_newDuration` is out of bounds.
     * - `AccessControlUnauthorizedAccount` if the caller does not have the `DEFAULT_ADMIN_ROLE`.
     *
     * @custom:emits
     * - Emits {EpochDurationUpdated} event upon successful epoch duration update.
     */
    function setEpochDuration(uint32 _newDuration) external onlyAdmin {
        uint32 oldDuration = _setEpochDuration(_newDuration);

        emit EpochDurationUpdated(msg.sender, oldDuration, _newDuration);
    }

    /**
     * @notice Sets the minimum yield required per epoch as a WAD-scaled percentage of the total principal.
     * @dev Restricted to admin role. The yield must be below the `MIN_YIELD_PER_EPOCH_UPPER_BOUND`.
     * @param _newMinYieldPercent The new minimum yield as a WAD-scaled percentage.
     *
     * @custom:requirements
     * - `_newMinYieldPercent` must be below the `MIN_YIELD_PER_EPOCH_UPPER_BOUND`.
     * - caller must have the admin role.
     *
     * @custom:reverts
     * - `MinYieldPerEpochOutOfBounds` if `_newMinYieldPercent` is out of bounds.
     * - `AccessControlUnauthorizedAccount` if the caller does not have the `DEFAULT_ADMIN_ROLE`.
     *
     * @custom:emits
     * - Emits {MinYieldPerEpochUpdated} event upon successful yield update.
     */
    function setMinYieldPerEpoch(uint64 _newMinYieldPercent) external onlyAdmin {
        uint64 oldMinYield = _setMinYieldPerEpoch(_newMinYieldPercent);

        emit MinYieldPerEpochUpdated(msg.sender, oldMinYield, _newMinYieldPercent);
    }

    /**
     * @notice Sets the maximum discrepancy between the expected and actual DCA token amounts for a claim.
     * @dev Restricted to admin role. The discrepancy must be below the `DISCREPANCY_TOLERANCE_UPPER_BOUND`.
     * @param _newTolerance The new discrepancy tolerance as a WAD-scaled percentage.
     *
     * @custom:requirements
     * - `_newTolerance` must be below the `DISCREPANCY_TOLERANCE_UPPER_BOUND`.
     * - caller must have the admin role.
     *
     * @custom:reverts
     * - `DiscrepancyToleranceOutOfBounds` if `_newTolerance` is out of bounds.
     * - `AccessControlUnauthorizedAccount` if the caller does not have the `DEFAULT_ADMIN_ROLE`.
     *
     * @custom:emits
     * - Emits {DiscrepancyToleranceUpdated} event upon successful tolerance update.
     */
    function setDiscrepancyTolerance(uint64 _newTolerance) external onlyAdmin {
        if (_newTolerance > DISCREPANCY_TOLERANCE_UPPER_BOUND) revert DiscrepancyToleranceOutOfBounds();

        emit DiscrepancyToleranceUpdated(msg.sender, discrepancyTolerance, _newTolerance);

        discrepancyTolerance = _newTolerance;
    }

    // *** user functions ***

    /**
     * @notice Opens a new DCA position with a specified amount of shares and assigns it to an owner.
     * @dev Transfers the specified amount of shares from the caller to the contract, creates a new position for the owner, and mints an NFT representing the position.
     * The value of the shares (i.e., principal) is recorded and used to determine the yield between epochs.
     * @param _owner The address that will own the new position.
     * @param _shares The amount of shares to deposit into the new position.
     * @return positionId The ID of the newly created position.
     *
     * @custom:requirements
     * - `_shares` must be greater than zero.
     * - The caller must have approved the contract to transfer `_shares` from their address.
     * - If the owner is a contract, it must implement `IERC721Receiver-onERC721Received` to receive the NFT.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_shares` is zero.
     * - `TransferToZeroAddress' if the owner is the zero address.
     * - `TransferToNonERC721ReceiverImplementer` if the owner is a contract without `IERC721Receiver-onERC721Received`.
     * - 'TransferFromFailed' if the transfer of shares fails.
     * 
     * @custom:emits
     * - Emits {PositionOpened} event upon successful position opening.
     */
    function openPosition(address _owner, uint256 _shares) public returns (uint256 positionId) {
        _shares.revertIfZero();

        positionId = _openPosition(_shares, _owner);

        address(vault).safeTransferFrom(msg.sender, address(this), _shares);
    }

    /**
     * @notice Opens a new DCA position with a specified amount of shares and assigns it to an owner using an ERC20 permit.
     * @dev Uses an ERC20 permit to obtain approval for transferring the specified amount of shares from the caller to the contract, creates a new position for the owner, and mints an NFT representing the position.
     * The value of the shares (i.e., principal) is recorded and used to determine the yield between epochs.
     * @param _owner The address that will own the new position.
     * @param _shares The amount of shares to deposit into the new position.
     * @param _deadline The timestamp by which the permit must be used.
     * @param _v The recovery byte of the permit signature.
     * @param _r Half of the ECDSA signature pair.
     * @param _s Half of the ECDSA signature pair.
     * @return positionId The ID of the newly created position.
     *
     * @custom:requirements
     * - `_shares` must be greater than zero.
     * - The permit must be valid and approved by the caller.
     * - If the owner is a contract, it must implement `IERC721Receiver-onERC721Received` to receive the NFT.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_shares` is zero.
     * - `TransferToZeroAddress' if the owner is the zero address.
     * - `TransferToNonERC721ReceiverImplementer` if the owner is a contract without `IERC721Receiver-onERC721Received`.
     *
     * @custom:emits
     * - Emits {PositionOpened} event upon successful position opening.
     */
    function openPositionUsingPermit(
        address _owner,
        uint256 _shares,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external returns (uint256 positionId) {
        IERC20Permit(address(vault)).permit(msg.sender, address(this), _shares, _deadline, _v, _r, _s);

        positionId = openPosition(_owner, _shares);
    }

    /**
     * @notice Deposits a specified amount of the vault's underlying asset and opens a new DCA position for the owner.
     * @dev Transfers the specified amount of the vault's underlying asset from the caller to the contract, deposits it into the vault, creates a new position for the owner with the received shares, and mints an NFT representing the position.
     * The amount of the vault's underlying asset (i.e., principal) is recorded and used to determine the yield between epochs.
     * @param _owner The address that will own the new position.
     * @param _principal The amount of the vault's underlying asset to deposit.
     * @return positionId The ID of the newly created position.
     *
     * @custom:requirements
     * - `_principal` must be greater than zero.
     * - The caller must have approved the contract to transfer `_principal` of the vault's underlying asset from their address.
     * - If the owner is a contract, it must implement `IERC721Receiver-onERC721Received` to receive the NFT.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_principal` is zero.
     * - `TransferToZeroAddress' if the owner is the zero address.
     * - `TransferToNonERC721ReceiverImplementer` if the owner is a contract without `IERC721Receiver-onERC721Received`.
     *
     * @custom:emits
     * - Emits {PositionOpened} event upon successful position opening.
     */
    function depositAndOpenPosition(address _owner, uint256 _principal) public returns (uint256 positionId) {
        _principal.revertIfZero();

        uint256 shares = _depositToVault(msg.sender, _principal);

        positionId = _openPosition(shares, _owner);
    }

    /**
     * @notice Deposits a specified amount of the vault's underlying asset and opens a new DCA position for the owner using an ERC20 permit.
     * @dev Uses an ERC20 permit to obtain approval for transferring the specified amount of the vault's underlying asset from the caller to the contract, deposits it into the vault, creates a new position for the owner with the received shares, and mints an NFT representing the position.
     * The amount of the vault's underlying asset (i.e., principal) is recorded and used to determine the yield between epochs.
     * @param _owner The address that will own the new position.
     * @param _principal The amount of the vault's underlying asset to deposit.
     * @param _deadline The timestamp by which the permit must be used.
     * @param _v The recovery byte of the permit signature.
     * @param _r Half of the ECDSA signature pair.
     * @param _s Half of the ECDSA signature pair.
     * @return positionId The ID of the newly created position.
     *
     * @custom:requirements
     * - `_principal` must be greater than zero.
     * - The permit must be valid and approved by the caller.
     * - If the owner is a contract, it must implement `IERC721Receiver-onERC721Received` to receive the NFT.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_principal` is zero.
     * - `TransferToZeroAddress' if the owner is the zero address.
     * - `TransferToNonERC721ReceiverImplementer` if the owner is a contract without `IERC721Receiver-onERC721Received`.
     *
     * @custom:emits
     * - Emits {PositionOpened} event upon successful position opening.
     */
    function depositAndOpenPositionUsingPermit(
        address _owner,
        uint256 _principal,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) public returns (uint256 positionId) {
        IERC20Permit(address(asset)).permit(msg.sender, address(this), _principal, _deadline, _v, _r, _s);

        positionId = depositAndOpenPosition(_owner, _principal);
    }

    /**
     * @notice Increases an existing DCA position by adding more shares.
     * @dev Transfers the specified amount of shares from the owner of the position to the contract and increases the specified position with the additional shares.
     * The value of the additional shares is added to the principal and used to determine the yield between epochs.
     * @param _positionId The ID of the position to be increased.
     * @param _shares The amount of shares to add to the position.
     *
     * @custom:requirements
     * - `_shares` must be greater than zero.
     * - The owner of the position must have approved the contract to transfer `_shares` from their address.
     * - The caller must be the owner or an approved operator of the position.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_shares` is zero.
     * - `TransferFromFailed` if the transfer of shares fails.
     * - `NotOwnerNorApproved` if the caller is neither the owner nor an approved operator of the position or if the position does not exist.
     * 
     * @custom:emits
     * - Emits {PositionIncreased} event upon successful position increase.
     */
    function increasePosition(uint256 _positionId, uint256 _shares) public {
        _shares.revertIfZero();
        _checkApprovedOrOwner(_positionId);

        uint256 principal = vault.convertToAssets(_shares);

        _increasePosition(_positionId, _shares, principal);

        address(vault).safeTransferFrom(_ownerOf(_positionId), address(this), _shares);
    }

    /**
     * @notice Increases an existing DCA position by adding more shares using an ERC20 permit.
     * @dev Uses an ERC20 permit to obtain approval for transferring the specified amount of shares from the owner of the position to the contract and increases the specified position with the additional shares.
     * The value of the additional shares is added to the principal and used to determine the yield between epochs.
     * @param _positionId The ID of the position to be increased.
     * @param _shares The amount of shares to add to the position.
     * @param _deadline The timestamp by which the permit must be used.
     * @param _v The recovery byte of the permit signature.
     * @param _r Half of the ECDSA signature pair.
     * @param _s Half of the ECDSA signature pair.
     *
     * @custom:requirements
     * - `_shares` must be greater than zero.
     * - The permit must be valid and approved by the owner of the position.
     * - The caller must be the owner or an approved operator of the position.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_shares` is zero.
     * - `TransferFromFailed` if the transfer of shares fails.
     * - `NotOwnerNorApproved` if the caller is neither the owner nor an approved operator of the position or if the position does not exist.
     * 
     *
     * @custom:emits
     * - Emits {PositionIncreased} event upon successful position increase.
     */
    function increasePositionUsingPermit(
        uint256 _positionId,
        uint256 _shares,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external {
        IERC20Permit(address(vault)).permit(_ownerOf(_positionId), address(this), _shares, _deadline, _v, _r, _s);

        increasePosition(_positionId, _shares);
    }

    /**
     * @notice Increases an existing DCA position by depositing a specified amount of the vault's underlying asset.
     * @dev Transfers the specified amount of the vault's underlying asset from the caller to the contract, deposits it into the vault, and increases the specified position with the received shares.
     * The value of the additional shares is added to the principal and used to determine the yield between epochs.
     * @param _positionId The ID of the position to be increased.
     * @param _assets The amount of the vault's underlying asset to deposit.
     *
     * @custom:requirements
     * - `_assets` must be greater than zero.
     * - The caller must have approved the contract to transfer `_assets` of the vault's underlying asset from their address.
     * - The caller must be the owner or an approved operator of the position.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_assets` is zero.
     * - `TransferFromFailed` if the transfer of assets fails.
     * - `NotOwnerNorApproved` if the caller is neither the owner nor an approved operator of the position or if the position does not exist.
     *
     * @custom:emits
     * - Emits {PositionIncreased} event upon successful position increase.
     */
    function depositAndIncreasePosition(uint256 _positionId, uint256 _assets) public {
        _assets.revertIfZero();
        _checkApprovedOrOwner(_positionId);

        uint256 shares = _depositToVault(_ownerOf(_positionId), _assets);

        _increasePosition(_positionId, shares, _assets);
    }

    /**
     * @notice Increases an existing DCA position by depositing a specified amount of the vault's underlying asset using an ERC20 permit.
     * @dev Uses an ERC20 permit to obtain approval for transferring the specified amount of the vault's underlying asset from the caller to the contract, deposits it into the vault, and increases the specified position with the received shares.
     * The value of the additional shares is added to the principal and used to determine the yield between epochs.
     * @param _positionId The ID of the position to be increased.
     * @param _assets The amount of the vault's underlying asset to deposit.
     * @param _deadline The timestamp by which the permit must be used.
     * @param _v The recovery byte of the permit signature.
     * @param _r Half of the ECDSA signature pair.
     * @param _s Half of the ECDSA signature pair.
     *
     * @custom:requirements
     * - `_assets` must be greater than zero.
     * - The permit must be valid and approved by the owner of the position.
     * - The caller must be the owner or an approved operator of the position.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_assets` is zero.
     * - `TransferFromFailed` if the transfer of assets fails.
     * - `NotOwnerNorApproved` if the caller is neither the owner nor an approved operator of the position or if the position does not exist.
     *
     * @custom:emits
     * - Emits {PositionIncreased} event upon successful position increase.
     */
    function depositAndIncreasePositionUsingPermit(
        uint256 _positionId,
        uint256 _assets,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external {
        IERC20Permit(address(asset)).permit(_ownerOf(_positionId), address(this), _assets, _deadline, _v, _r, _s);

        depositAndIncreasePosition(_positionId, _assets);
    }

    /**
     * @notice Reduces an existing DCA position by withdrawing a specified amount of shares.
     * @dev Transfers the specified amount of shares from the contract to the owner of the position and reduces the specified position accordingly.
     * If all shares are withdrawn, the position is closed, the NFT representing the position is burned, and the DCA balance is transferred to the owner.
     * @param _positionId The ID of the position to be reduced.
     * @param _shares The amount of shares to withdraw from the position.
     *
     * @custom:requirements
     * - `_shares` must be greater than zero.
     * - The caller must be the owner or an approved operator of the position.
     * - The position must have sufficient shares to withdraw.
     *
     * @custom:reverts
     * - `ZeroAmount` if `_shares` is zero.
     * - `NotOwnerNorApproved` if the caller is neither the owner nor an approved operator of the position or if the position does not exist.
     * - `InsufficientSharesToWithdraw` if the position does not have sufficient shares to withdraw.
     *
     * @custom:emits
     * - Emits {PositionReduced} event upon successful position reduction.
     * - Emits {PositionClosed} event if all shares are withdrawn.
     */
    function reducePosition(uint256 _positionId, uint256 _shares) external {
        _shares.revertIfZero();
        _checkApprovedOrOwner(_positionId);

        Position storage position = positions[_positionId];
        uint32 epoch = currentEpoch;
        (uint256 sharesBalance_, uint224 dcaBalance_) = _calculateBalances(position, epoch);

        if (_shares != sharesBalance_) {
            _reducePosition(position, _positionId, epoch, _shares, sharesBalance_, dcaBalance_);
            return;
        }

        _closePosition(_positionId, position.principal, sharesBalance_, dcaBalance_);
    }

    /**
     * @notice Closes an existing DCA position by withdrawing all shares.
     * @dev Transfers all shares and the DCA balance from the contract to the owner of the position, burns the NFT representing the position, and removes the position.
     * @param _positionId The ID of the position to be closed.
     *
     * @custom:requirements
     * - The caller must be the owner or an approved operator of the position.
     *
     * @custom:reverts
     * - `NotOwnerNorApproved` if the caller is neither the owner nor an approved operator of the position or if the position does not exist. 
     *
     * @custom:emits
     * - Emits {PositionClosed} event upon successful position closing.
     */
    function closePosition(uint256 _positionId) external {
        _checkApprovedOrOwner(_positionId);

        Position storage position = positions[_positionId];
        uint32 epoch = currentEpoch;
        (uint256 shares, uint256 _dcaBalance) = _calculateBalances(position, epoch);

        _closePosition(_positionId, position.principal, shares, _dcaBalance);
    }

    /**
     * @notice Claims the accumulated DCA balance for a specific position and transfers it to a specified address.
     * @dev Transfers the DCA balance from the contract to the specified address and updates the position's DCA balance.
     * @param _positionId The ID of the position for which to claim the DCA balance.
     * @param _to The address to which the DCA balance will be transferred.
     * @return amount The amount of DCA tokens claimed.
     *
     * @custom:requirements
     * - The caller must be the owner or an approved operator of the position.
     * - The `_to` address must not be zero.
     * - The position must have a non-zero DCA balance.
     *
     * @custom:reverts
     * - `NotOwnerNorApproved` if the caller is neither the owner nor an approved operator of the position or if the position does not exist.
     * - `NothingToClaim` if the position has no DCA balance to claim.
     * - `ZeroAddress` if the `_to` address is the zero address.
     * - `DCADiscrepancyAboveTolerance` if the claimed DCA amount is above the discrepancy tolerance.
     *
     * @custom:emits
     * - Emits {DCABalanceClaimed} event upon successful balance claim.
     */
    function claimDCABalance(uint256 _positionId, address _to) external returns (uint256 amount) {
        _to.revertIfZero();
        _checkApprovedOrOwner(_positionId);

        // calculate the DCA balance for the position
        Position storage position = positions[_positionId];
        uint32 epoch = currentEpoch;
        (position.shares, amount) = _calculateBalances(position, epoch);

        amount.revertIfZero(NothingToClaim.selector);

        // update the position and transfer the DCA amount
        position.epoch = epoch;
        position.dcaBalance = 0;

        amount = _transferDcaTokens(_to, amount);

        emit DCABalanceClaimed(msg.sender, _ownerOf(_positionId), _positionId, epoch, amount, _to);
    }

    // *** keeper functions ***

    /**
     * @notice Executes the DCA strategy for the current epoch by converting yield into DCA tokens.
     * @dev Redeems yield from the vault, swaps it for DCA tokens using the swapper contract, updates the epoch information, and starts a new epoch.
     * @param _dcaAmountOutMin The minimum amount of DCA tokens expected from the swap.
     * @param _swapData The data required by the swapper contract to perform the swap.
     *
     * @custom:requirements
     * - The caller must have the KEEPER_ROLE.
     * - The epoch duration must have been reached.
     * - The yield must be sufficient to meet the minimum yield per epoch requirement.
     *
     * @custom:reverts
     * - `EpochDurationNotReached` if the epoch duration has not been reached.
     * - `InsufficientYield` if the yield is not sufficient to meet the minimum yield per epoch.
     * - `AmountReceivedTooLow` if the amount of DCA tokens received is below the minimum expected amount.
     *
     * @custom:emits
     * - Emits {DCAExecuted} event upon successful DCA execution.
     */
    function executeDCA(uint256 _dcaAmountOutMin, bytes calldata _swapData) external nonReentrant onlyRole(KEEPER_ROLE) {
        _checkEpochDuration();

        // calculate yield in shares and redeem from the vault
        uint256 totalPrincipal_ = totalPrincipal;
        uint256 yieldInShares = _calculateYieldInShares(totalPrincipal_);

        vault.redeem(yieldInShares, address(this), address(this));

        uint256 yield = asset.balanceOf(address(this));

        _checkMinYieldPerEpoch(yield, totalPrincipal_);

        // swap yield for DCA tokens
        uint256 amountOut = _buyDcaTokens(yield, _dcaAmountOutMin, _swapData);

        // update epoch information
        uint128 dcaPrice = amountOut.divWad(yield).toUint128();
        uint128 sharePrice = yield.divWad(yieldInShares).toUint128();

        uint32 epoch;
        unchecked {
            epoch = currentEpoch++;
        }

        epochInfos[epoch] = EpochInfo({dcaPrice: dcaPrice, sharePrice: sharePrice});
        currentEpochTimestamp = uint64(block.timestamp);

        emit DCAExecuted(msg.sender, epoch, yield, amountOut, dcaPrice, sharePrice);
    }

    /**
     * @notice Sets the IPFS CID (Content Identifier) for a given token (position) ID.
     * @dev This function allows the owner or an approved operator to set the CID for a token.
     * The CID is used to generate the tokenURI.
     * @param _positionId The ID of the token to set the CID for.
     * @param _cid The CID to be associated with the token.
     *
     * @custom:requirements
     * - The `_cid` must not be an empty string.
     * - The caller must be the owner or an approved operator of the `_positionId`.
     *
     * @custom:reverts
     * - `EmptyCID` if the `_cid` is an empty string.
     * - `ERC721.NotOwnerNorApproved` if the caller is not the owner or an approved operator or if the position does not exist.
     *
     * @custom:emits
     * - Emits a {TokenCIDUpdated} event upon successful CID update.
     */
    function setTokenCID(uint256 _positionId, string memory _cid) public {
        bytes(_cid).length.revertIfZero(EmptyCID.selector);
        _checkApprovedOrOwner(_positionId);

        tokenCIDs[_positionId] = _cid;

        emit TokenCIDUpdated(msg.sender, _ownerOf(_positionId), _positionId, _cid);
    }

    // *** view functions ***

    /// @inheritdoc ERC721
    function name() public view override returns (string memory) {
        return name_;
    }

    /// @inheritdoc ERC721
    function symbol() public view override returns (string memory) {
        return symbol_;
    }

    /**
     * @notice Returns the URI for a given token ID.
     * @dev This function returns the full IPFS URL based on the CID stored for the token.
     * If the CID is not set, it returns an empty string.
     * @param _tokenId The ID of the token to get the URI for.
     * @return The full IPFS URL for the token's metadata, or an empty string if no CID is set.
     *
     * @custom:requirements
     * - The `_tokenId` must represent an existing token.
     *
     * @custom:reverts
     * - `ERC721.TokenDoesNotExist` if the `_tokenId` does not represent an existing token.
     */
    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        if (!_exists(_tokenId)) revert ERC721.TokenDoesNotExist();

        string memory cid = tokenCIDs[_tokenId];

        if (bytes(cid).length == 0) return "";

        return string(abi.encodePacked("ipfs://", cid));
    }

    /**
     * @notice Checks if the contract implements a specific interface.
     * @dev Implements ERC165 standard for interface detection.
     * @param _interfaceId The interface identifier, as specified in ERC-165.
     * @return True if the contract implements the requested interface, false otherwise.
     */
    function supportsInterface(bytes4 _interfaceId)
        public
        view
        virtual
        override(ERC721, AccessControl)
        returns (bool)
    {
        return _interfaceId == type(IERC721).interfaceId || super.supportsInterface(_interfaceId);
    }

    /**
     * @notice Checks if the conditions are met to execute the DCA strategy for the current epoch.
     * @dev Meant to be called only off-chain to preview the DCA execution conditions.
     * @return True if the DCA strategy can be executed, reverts otherwise.
     *
     * @custom:requirements
     * - The epoch duration must have been reached.
     * - The yield must be sufficient to meet the minimum yield per epoch requirement.
     * 
     * @custom:reverts
     * - `EpochDurationNotReached` if the epoch duration has not been reached.
     * - `InsufficientYield` if the yield is not sufficient to meet the minimum yield per epoch.
     */
    function canExecuteDCA() external view returns (bool) {
        _checkEpochDuration();

        uint256 yieldInShares = _calculateYieldInShares(totalPrincipal);
        uint256 yield = vault.previewRedeem(yieldInShares);

        _checkMinYieldPerEpoch(yield, totalPrincipal);

        return true;
    }

    /**
     * @notice Calculates the yield generated in the current epoch expressed in asset units.
     * @dev This yield represents the total available assets minus the principal, so it can be negative.
     * @return The yield generated in the current epoch.
     */
    function calculateYield() public view returns (int256) {
        return int256(vault.convertToAssets(sharesBalance())) - int256(totalPrincipal);
    }

    /**
     * @notice Calculates the current yield expressed in the underlying ERC4626 vault shares.
     * @dev Useful for operations requiring share-based calculations. Reverts if the actual yield is zero or negative.
     * @return uint256 The yield expressed in shares.
     */
    function calculateYieldInShares() public view returns (uint256) {
        return _calculateYieldInShares(totalPrincipal);
    }

    /**
     * @notice Gets the balance of shares and DCA tokens for a specific position.
     * @param _positionId The ID of the position to check.
     * @return _sharesBalance The balance of shares for the position.
     * @return _dcaBalance The balance of DCA tokens for the position.
     */
    function balancesOf(uint256 _positionId) public view returns (uint256 _sharesBalance, uint256 _dcaBalance) {
        (_sharesBalance, _dcaBalance) = _calculateBalances(positions[_positionId], currentEpoch);
    }

    /**
     * @notice Gets the balance of DCA tokens held by this contract.
     * @dev Useful for checking how many DCA tokens are available for withdrawal or other operations.
     * @return The amount of DCA tokens currently held by the contract.
     */
    function dcaBalance() public view returns (uint256) {
        return dcaToken.balanceOf(address(this));
    }

    /**
     * @notice Gets the balance of vault shares held by this contract.
     * @dev Useful for operations that require knowledge of total shares under the control of the contract.
     * @return The total number of shares held by the contract.
     */
    function sharesBalance() public view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    /**
     * @notice Checks if an account is either the owner of a position or an approved operator.
     * @param _account The account to check.
     * @param _tokenId The ID of the position (token) to check.
     * @return True if the account is the owner or an approved operator of the position, false otherwise.
     */
    function isApprovedOrOwner(address _account, uint256 _tokenId) public view returns (bool) {
        return _isApprovedOrOwner(_account, _tokenId);
    }

    /*
    * =======================================================
    *                   INTERNAL FUNCTIONS
    * =======================================================
    */

    // *** admin functons ***

    function _setSwapper(ISwapper _newSwapper) internal returns (address oldSwapper) {
        address(_newSwapper).revertIfZero(SwapperAddressZero.selector);
        oldSwapper = address(swapper);

        // revoke previous swapper's approval and approve new swapper
        if (oldSwapper != address(0)) address(asset).safeApprove(oldSwapper, 0);
        address(asset).safeApprove(address(_newSwapper), type(uint256).max);

        swapper = _newSwapper;
    }

    function _setEpochDuration(uint32 _newDuration) internal returns (uint32 oldDuration) {
        if (_newDuration < EPOCH_DURATION_LOWER_BOUND || _newDuration > EPOCH_DURATION_UPPER_BOUND) {
            revert EpochDurationOutOfBounds();
        }

        oldDuration = epochDuration;
        epochDuration = _newDuration;
    }

    function _setMinYieldPerEpoch(uint64 _newMinYieldPercent) internal returns (uint64 oldMinYield) {
        if (_newMinYieldPercent > MIN_YIELD_PER_EPOCH_UPPER_BOUND) {
            revert MinYieldPerEpochOutOfBounds();
        }

        oldMinYield = minYieldPerEpoch;
        minYieldPerEpoch = _newMinYieldPercent;
    }

    // *** accounting functions ***

    function _openPosition(uint256 _shares, address _owner) internal returns (uint256 positionId) {
        uint32 epoch = currentEpoch;
        uint256 principal = vault.convertToAssets(_shares);

        unchecked {
            totalPrincipal += principal;
            positionId = nextPositionId++;
        }

        // if caller is a contract make sure it implements IERC721Receiver-onERC721Received by using safeMint
        _safeMint(_owner, positionId);

        positions[positionId] = Position({epoch: epoch, shares: _shares, principal: principal, dcaBalance: 0});

        emit PositionOpened(msg.sender, _owner, positionId, epoch, _shares, principal);
    }

    function _increasePosition(uint256 _positionId, uint256 _shares, uint256 _principal) internal {
        uint32 epoch = currentEpoch;
        Position storage position = positions[_positionId];

        // if deposit is from a previous epoch, update the balances
        if (position.epoch < epoch) {
            (position.shares, position.dcaBalance) = _calculateBalances(position, epoch);
        }

        unchecked {
            position.epoch = epoch;
            // overflow here is not realistic to happen
            position.shares += _shares;
            position.principal += _principal;

            totalPrincipal += _principal;
        }

        emit PositionIncreased(msg.sender, _ownerOf(_positionId), _positionId, epoch, _shares, _principal);
    }

    function _reducePosition(
        Position storage position,
        uint256 _positionId,
        uint32 _epoch,
        uint256 _shares,
        uint256 _sharesBalance,
        uint224 _dcaBalance
    ) internal {
        if (_shares > _sharesBalance) revert InsufficientSharesToWithdraw();

        uint256 principal = position.principal.mulDiv(_shares, _sharesBalance);

        position.epoch = _epoch;
        position.dcaBalance = _dcaBalance;

        unchecked {
            // cannot underflow because of sharesAvailable > _shares check
            position.shares = _sharesBalance - _shares;
            position.principal -= principal;
        }

        totalPrincipal -= principal;

        address owner = _ownerOf(_positionId);

        _shares = _transferShares(owner, _shares);

        emit PositionReduced(msg.sender, owner, _positionId, _epoch, _shares, principal);
    }

    function _closePosition(uint256 _positionId, uint256 _principal, uint256 _shares, uint256 _dcaBalance) internal {
        totalPrincipal -= _principal;
        address owner = _ownerOf(_positionId);

        delete tokenCIDs[_positionId];
        delete positions[_positionId];
        _burn(_positionId);

        _shares = _transferShares(owner, _shares);
        _dcaBalance = _transferDcaTokens(owner, _dcaBalance);

        emit PositionClosed(msg.sender, owner, _positionId, currentEpoch, _shares, _principal, _dcaBalance);
    }

    function _calculateYieldInShares(uint256 _totalPrincipal) internal view returns (uint256) {
        uint256 balance = sharesBalance();
        uint256 totalPrincipalInShares = vault.convertToShares(_totalPrincipal);

        if (balance <= totalPrincipalInShares) revert NoYield();

        unchecked {
            // cannot underflow because of the check above
            return balance - totalPrincipalInShares;
        }
    }

    function _calculateBalances(Position storage _position, uint32 _currentEpoch)
        internal
        view
        returns (uint256 _sharesBalance, uint224 _dcaBalance)
    {
        if (_position.epoch == 0) return (0, 0);

        _sharesBalance = _position.shares;
        uint256 calculatedDcaBalance = _position.dcaBalance;
        uint256 principal = _position.principal;

        // NOTE: one iteration costs less than 1000 gas in the test with 100 epochs?
        for (uint256 i = _position.epoch; i < _currentEpoch;) {
            EpochInfo memory info = epochInfos[i];
            // save gas on sload
            uint256 sharePrice = info.sharePrice;

            // round up to minimize rounding errors and prevent underestimation when calculating user's yield
            uint256 sharesValue = _sharesBalance.mulWadUp(sharePrice);

            unchecked {
                i++;

                if (sharesValue > principal) {
                    // cannot underflow because of the check above
                    uint256 usersYield = sharesValue - principal;

                    // cannot underflow because (yield / sharePrice) <= shares (yield is always less than principal)
                    _sharesBalance -= usersYield.divWad(sharePrice);
                    // not realistic to overflow (not fit into uint224) but just in case there is check below
                    // will overflow if total users yield adds up to 2^96
                    calculatedDcaBalance += usersYield.mulWad(info.dcaPrice);
                }
            }
        }

        // make sure the calculated dca balance fits into uint224
        _dcaBalance = calculatedDcaBalance.toUint224();
    }

    /// *** helper functions ***

    function _depositToVault(address _from, uint256 _principal) internal returns (uint256 shares) {
        address(asset).safeTransferFrom(_from, address(this), _principal);

        shares = vault.deposit(_principal, address(this));
    }

    function _transferShares(address _to, uint256 _shares) internal returns (uint256) {
        // limit to available shares because of possible rounding errors
        uint256 sharesBalance_ = sharesBalance();

        if (_shares > sharesBalance_) _shares = sharesBalance_;

        address(vault).safeTransfer(_to, _shares);

        return _shares;
    }

    function _transferDcaTokens(address _to, uint256 _amount) internal returns (uint256) {
        uint256 balance = dcaBalance();

        // limit to available or revert if amount discrepancy is above set tolerance
        if (_amount > balance) {
            unchecked {
                // cannot underflow because of the check above
                if (_amount - balance > _amount.mulWad(discrepancyTolerance)) {
                    revert DCADiscrepancyAboveTolerance();
                }
            }

            _amount = balance;
        }

        address(dcaToken).safeTransfer(_to, _amount);

        return _amount;
    }

    function _buyDcaTokens(uint256 _amountIn, uint256 _dcaAmountOutMin, bytes calldata _swapData)
        internal
        returns (uint256)
    {
        uint256 balanceBefore = dcaBalance();

        swapper.execute(address(asset), address(dcaToken), _amountIn, _dcaAmountOutMin, _swapData);

        uint256 balanceAfter = dcaBalance();

        if (balanceAfter < balanceBefore + _dcaAmountOutMin) revert AmountReceivedTooLow();

        unchecked {
            return balanceAfter - balanceBefore;
        }
    }

    function _checkApprovedOrOwner(uint256 _positionId) internal view {
        if (!_isApprovedOrOwner(msg.sender, _positionId)) revert ERC721.NotOwnerNorApproved();
    }

    function _checkEpochDuration() internal view {
        if (block.timestamp < currentEpochTimestamp + epochDuration) revert EpochDurationNotReached();
    }

    function _checkMinYieldPerEpoch(uint256 _yield, uint256 _totalPrincipal) internal view {
        if (minYieldPerEpoch != 0 && _yield < _totalPrincipal.mulWad(minYieldPerEpoch)) revert InsufficientYield();
    }
}
